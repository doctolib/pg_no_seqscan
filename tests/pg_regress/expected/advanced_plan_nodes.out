-- Test detection of sequential scans in Append
SET pg_no_seqscan.level = ERROR;
-- Test MergeAppend (UNION ALL with ORDER BY on partitioned table)
CREATE TABLE test_merge_parent (id int, data text);
CREATE TABLE test_merge_child1 (CHECK (id < 2)) INHERITS (test_merge_parent);
CREATE TABLE test_merge_child2 (CHECK (id >= 2)) INHERITS (test_merge_parent);
INSERT INTO test_merge_child1 SELECT i, 'data' || i FROM generate_series(1, 2) i;
ERROR:  new row for relation "test_merge_child1" violates check constraint "test_merge_child1_id_check"
INSERT INTO test_merge_child2 SELECT i, 'data' || i FROM generate_series(3, 4) i;
-- This should trigger MergeAppend and detect sequential scans in child tables
EXPLAIN SELECT * FROM test_merge_parent ORDER BY id LIMIT 5;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Limit  (cost=100.31..100.32 rows=5 width=36)
   ->  Sort  (cost=100.31..106.66 rows=2541 width=36)
         Sort Key: test_merge_parent.id
         ->  Append  (cost=0.00..58.11 rows=2541 width=36)
               ->  Seq Scan on test_merge_parent test_merge_parent_1  (cost=0.00..0.00 rows=1 width=36)
               ->  Seq Scan on test_merge_child1 test_merge_parent_2  (cost=0.00..22.70 rows=1270 width=36)
               ->  Seq Scan on test_merge_child2 test_merge_parent_3  (cost=0.00..22.70 rows=1270 width=36)
(7 rows)

SELECT * FROM test_merge_parent ORDER BY id LIMIT 5;
ERROR:  A 'Sequential Scan' on test_merge_parent,test_merge_child1,test_merge_child2 has been detected.
  - Run an EXPLAIN on your query to check the query plan.
  - Make sure the query is compatible with the existing indexes.

Query: SELECT * FROM test_merge_parent ORDER BY id LIMIT 5;

DROP TABLE test_merge_parent CASCADE;
Make sure CI fails :)