-- Test partitioning support
select Substr(setting, 1, 2) = '18' from pg_settings where name = 'server_version_num'; -- output changed slightly from PG18
 ?column? 
----------
 t
(1 row)

-- Setup
LOAD 'pg_no_seqscan';
SET pg_no_seqscan.level = ERROR;
SET enable_seqscan = off;
CREATE TABLE partitioned_foo (id bigint) PARTITION BY RANGE (id);
CREATE TABLE partitioned_foo_1 PARTITION OF partitioned_foo FOR VALUES FROM (1) TO (5);
CREATE TABLE partitioned_foo_2 PARTITION OF partitioned_foo FOR VALUES FROM (5) TO (11) PARTITION BY RANGE (id);
CREATE TABLE partitioned_foo_2_1 PARTITION OF partitioned_foo_2 FOR VALUES FROM (5) TO (8);
CREATE TABLE partitioned_foo_2_2 PARTITION OF partitioned_foo_2 FOR VALUES FROM (8) TO (11);
INSERT INTO partitioned_foo SELECT i FROM generate_series(1, 10) i;
CREATE INDEX on partitioned_foo_1 USING btree (id);
-- show data distribution
SELECT id, tableoid::regclass from partitioned_foo ORDER BY id /*pg_no_seqscan_skip*/;
 id |      tableoid       
----+---------------------
  1 | partitioned_foo_1
  2 | partitioned_foo_1
  3 | partitioned_foo_1
  4 | partitioned_foo_1
  5 | partitioned_foo_2_1
  6 | partitioned_foo_2_1
  7 | partitioned_foo_2_1
  8 | partitioned_foo_2_2
  9 | partitioned_foo_2_2
 10 | partitioned_foo_2_2
(10 rows)

-- Blocks query execution as no table settings are defined
EXPLAIN (COSTS OFF) SELECT id, tableoid::regclass from partitioned_foo ORDER BY id;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort
   Sort Key: partitioned_foo.id
   ->  Append
         ->  Index Scan using partitioned_foo_1_id_idx on partitioned_foo_1
         ->  Seq Scan on partitioned_foo_2_1 partitioned_foo_2
               Disabled: true
         ->  Seq Scan on partitioned_foo_2_2 partitioned_foo_3
               Disabled: true
(8 rows)

SELECT id, tableoid::regclass from partitioned_foo ORDER BY id;
ERROR:  A 'Sequential Scan' has been detected. Make sure the query is compatible with the existing indexes.
  - Tables involved: partitioned_foo
  - Query: SELECT id, tableoid::regclass from partitioned_foo ORDER BY id;
  - Query plan:

  Sort
  Sort Key: partitioned_foo.id
  ->  Append
        ->  Index Scan using partitioned_foo_1_id_idx on partitioned_foo_1
        ->  Seq Scan on partitioned_foo_2_1 partitioned_foo_2
              Disabled: true
        ->  Seq Scan on partitioned_foo_2_2 partitioned_foo_3
              Disabled: true


-- Blocks query execution as root table appears in check_tables settings
SET pg_no_seqscan.check_tables = 'partitioned_foo';
SELECT id, tableoid::regclass from partitioned_foo ORDER BY id;
ERROR:  A 'Sequential Scan' has been detected. Make sure the query is compatible with the existing indexes.
  - Tables involved: partitioned_foo
  - Query: SELECT id, tableoid::regclass from partitioned_foo ORDER BY id;
  - Query plan:

  Sort
  Sort Key: partitioned_foo.id
  ->  Append
        ->  Index Scan using partitioned_foo_1_id_idx on partitioned_foo_1
        ->  Seq Scan on partitioned_foo_2_1 partitioned_foo_2
              Disabled: true
        ->  Seq Scan on partitioned_foo_2_2 partitioned_foo_3
              Disabled: true


-- Allows query execution as root table appears in ignore_tables settings
RESET pg_no_seqscan.check_tables;
SET pg_no_seqscan.ignore_tables = 'partitioned_foo';
SELECT id, tableoid::regclass from partitioned_foo ORDER BY id;
 id |      tableoid       
----+---------------------
  1 | partitioned_foo_1
  2 | partitioned_foo_1
  3 | partitioned_foo_1
  4 | partitioned_foo_1
  5 | partitioned_foo_2_1
  6 | partitioned_foo_2_1
  7 | partitioned_foo_2_1
  8 | partitioned_foo_2_2
  9 | partitioned_foo_2_2
 10 | partitioned_foo_2_2
(10 rows)

-- Cleanup
DROP TABLE partitioned_foo cascade;
